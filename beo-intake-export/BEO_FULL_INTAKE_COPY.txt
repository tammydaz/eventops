ccan you give me it in an omni promt for sonnet 
ok now i had 5.2 alayze my dropbox does this contradict anything.  this is for the speck engineYes.
Here is the Spec Engine Logic, clean, structured, and separated into:

Observed Dropbox Rules (non-negotiable)

Guardrails we added

Decision Order

Pseudocode version you can hand to Sonnet/Gemini

No fluff. No invention beyond what we explicitly layered.

üß† FOODWERX SPEC ENGINE LOGIC (CANONICAL)
I. CORE PRINCIPLES (LOCKED)
1Ô∏è‚É£ Human Placement Is Gospel

The engine reads:

Passed Appetizers

Presented Appetizers

Buffet ‚Äì Metal

Buffet ‚Äì China

Desserts

It may NEVER:

Move items between sections

Reinterpret placement

Infer placement

Change vessel type

If placement is unclear ‚Üí
UNKNOWN ‚Äî requires human decision

2Ô∏è‚É£ Quantity Logic Is Pattern-Based (NOT Linear)

The engine:

Does NOT use ounces-per-guest math

Does NOT divide guest count evenly across items

Does NOT auto-balance menu items

Instead it uses:

Guest count bands

Redundancy logic

Primary vs Filler distinction

Service interaction (passed + buffet compression)

3Ô∏è‚É£ Overrides Are Sacred

If a human has entered:

Quantity

Vessel

Notes

The engine MUST:

Leave it untouched

Never recalc

Never normalize

Engine may only initialize fields if they are empty.

4Ô∏è‚É£ Language Must Match Operational Terminology

Allowed vocabulary:

Full pan

Half pan

Round pan

Primary protein

Filler item

Light touch

Grazing volume

Server to build on site

Pack separately

No generic catering terms.
No industry yield charts.

II. OBSERVED BEHAVIOR RULES (FROM DROPBOX)
A. Guest Count Bands (Behavioral, Not Mathematical)

These are switches, not formulas.

Guest Count	Behavior
‚â§ 75	Conservative pan counts
75‚Äì125	Standard full-service behavior
125‚Äì175	Redundancy begins compressing items
175‚Äì250	Clear primary vs filler split
250+	Volume scaling flattens

Important:
Scaling is not proportional.

B. Redundancy Logic

If multiple proteins exist:

Each protein receives LESS than if solo.

If:

Pasta

Starch

Bread

Grazing displays

Passed appetizers

Are present:
‚Üí Buffet volume decreases.

If Passed + Buffet both exist:
‚Üí Buffet compression increases.

C. Placement-Specific Tendencies
Passed Apps

Smaller batches

Often marked:

‚ÄúServer to build on site‚Äù

‚ÄúPack separately‚Äù

Buffet Primary Protein

Drives chafer logic

Usually full or round pan

Buffet Filler

Often half pans

Sometimes no chafer

Desserts

Count logic differs (pieces vs pans)

Often less aggressive scaling

III. CHAFER / VESSEL LOGIC (LOCKED)

Per unique menu item:

Full pan ‚Üí 1 chafer

2 half pans ‚Üí 1 chafer

Odd half ‚Üí flag

Round pan ‚Üí round chafer

Enforced per item, not per quantity batch

Engine may never infer vessel type from:

‚ÄúHot‚Äù

‚ÄúCold‚Äù

Item name

IV. GUARDRAILS WE ADDED (ARCHITECTURAL TIGHTENING)

These are NOT Dropbox-derived but were intentionally layered.

1Ô∏è‚É£ Initialize-Only Pattern

Engine may:

Suggest default spec
ONLY IF field is empty.

After human edit:
‚Üí Spec becomes read-only.

2Ô∏è‚É£ Confidence Threshold

If:

Guest band conflicts with redundancy pattern

No historical pattern match

Placement is missing

Engine outputs:

UNKNOWN ‚Äî requires human decision

Never guess.

3Ô∏è‚É£ Decision Order Lock

The engine must evaluate in this order:

Menu item exists

Human placement selected

Guest count band determined

Redundancy evaluated

Primary vs filler evaluated

Vessel confirmed (or pre-set)

Quantity suggested (if empty)

Never skip steps.
Never reverse order.

V. SPEC ENGINE FLOW (PSEUDOCODE)

Here is the clean build-ready version.

FOR each menu_item IN event.menu_sections:

    IF menu_item.quantity EXISTS:
        CONTINUE (sacred override)

    IF placement NOT defined:
        OUTPUT UNKNOWN
        CONTINUE

    guest_band = determine_guest_band(event.guest_count)

    redundancy_score = evaluate_redundancy(event.menu_sections)

    role = classify_item(menu_item)
        ‚Üí primary_protein
        ‚Üí filler
        ‚Üí dessert
        ‚Üí passed_app

    vessel = menu_item.vessel
        IF vessel empty:
            DO NOT GUESS
            OUTPUT UNKNOWN

    quantity = derive_quantity(
        guest_band,
        role,
        redundancy_score,
        placement
    )

    RETURN spec block:
        - vessel
        - quantity
        - flags (build_on_site, pack_separately)

VI. WHAT THE ENGINE MUST NEVER DO

‚ùå Linear scaling
‚ùå Equal distribution
‚ùå Normalize quantities
‚ùå Change vessels
‚ùå Merge items
‚ùå Optimize menu balance
‚ùå Write to print fields
‚ùå Overwrite Nick

VII. SPEC VS PACK-OUT SEPARATION

Spec Engine determines:

Food intent

Pan type

Volume suggestion

Pack-Out Engine determines:

Equipment

Static essentials

Bar/hydration additions

They are separate modules.

Final Definition

The FoodWerx Spec Engine is:

A pattern-based decision engine that mirrors historical catering behavior using guest bands and redundancy compression, while enforcing sacred human overrides and refusing to guess when confidence is insufficient.can you give me it in an omni promt for sonnet 
ok now i had 5.2 alayze my dropbox does this contradict anything.  this is for the speck engineYes.
Here is the Spec Engine Logic, clean, structured, and separated into:

Observed Dropbox Rules (non-negotiable)

Guardrails we added

Decision Order

Pseudocode version you can hand to Sonnet/Gemini

No fluff. No invention beyond what we explicitly layered.

üß† FOODWERX SPEC ENGINE LOGIC (CANONICAL)
I. CORE PRINCIPLES (LOCKED)
1Ô∏è‚É£ Human Placement Is Gospel

The engine reads:

Passed Appetizers

Presented Appetizers

Buffet ‚Äì Metal

Buffet ‚Äì China

Desserts

It may NEVER:

Move items between sections

Reinterpret placement

Infer placement

Change vessel type

If placement is unclear ‚Üí
UNKNOWN ‚Äî requires human decision

2Ô∏è‚É£ Quantity Logic Is Pattern-Based (NOT Linear)

The engine:

Does NOT use ounces-per-guest math

Does NOT divide guest count evenly across items

Does NOT auto-balance menu items

Instead it uses:

Guest count bands

Redundancy logic

Primary vs Filler distinction

Service interaction (passed + buffet compression)

3Ô∏è‚É£ Overrides Are Sacred

If a human has entered:

Quantity

Vessel

Notes

The engine MUST:

Leave it untouched

Never recalc

Never normalize

Engine may only initialize fields if they are empty.

4Ô∏è‚É£ Language Must Match Operational Terminology

Allowed vocabulary:

Full pan

Half pan

Round pan

Primary protein

Filler item

Light touch

Grazing volume

Server to build on site

Pack separately

No generic catering terms.
No industry yield charts.

II. OBSERVED BEHAVIOR RULES (FROM DROPBOX)
A. Guest Count Bands (Behavioral, Not Mathematical)

These are switches, not formulas.

Guest Count	Behavior
‚â§ 75	Conservative pan counts
75‚Äì125	Standard full-service behavior
125‚Äì175	Redundancy begins compressing items
175‚Äì250	Clear primary vs filler split
250+	Volume scaling flattens

Important:
Scaling is not proportional.

B. Redundancy Logic

If multiple proteins exist:

Each protein receives LESS than if solo.

If:

Pasta

Starch

Bread

Grazing displays

Passed appetizers

Are present:
‚Üí Buffet volume decreases.

If Passed + Buffet both exist:
‚Üí Buffet compression increases.

C. Placement-Specific Tendencies
Passed Apps

Smaller batches

Often marked:

‚ÄúServer to build on site‚Äù

‚ÄúPack separately‚Äù

Buffet Primary Protein

Drives chafer logic

Usually full or round pan

Buffet Filler

Often half pans

Sometimes no chafer

Desserts

Count logic differs (pieces vs pans)

Often less aggressive scaling

III. CHAFER / VESSEL LOGIC (LOCKED)

Per unique menu item:

Full pan ‚Üí 1 chafer

2 half pans ‚Üí 1 chafer

Odd half ‚Üí flag

Round pan ‚Üí round chafer

Enforced per item, not per quantity batch

Engine may never infer vessel type from:

‚ÄúHot‚Äù

‚ÄúCold‚Äù

Item name

IV. GUARDRAILS WE ADDED (ARCHITECTURAL TIGHTENING)

These are NOT Dropbox-derived but were intentionally layered.

1Ô∏è‚É£ Initialize-Only Pattern

Engine may:

Suggest default spec
ONLY IF field is empty.

After human edit:
‚Üí Spec becomes read-only.

2Ô∏è‚É£ Confidence Threshold

If:

Guest band conflicts with redundancy pattern

No historical pattern match

Placement is missing

Engine outputs:

UNKNOWN ‚Äî requires human decision

Never guess.

3Ô∏è‚É£ Decision Order Lock

The engine must evaluate in this order:

Menu item exists

Human placement selected

Guest count band determined

Redundancy evaluated

Primary vs filler evaluated

Vessel confirmed (or pre-set)

Quantity suggested (if empty)

Never skip steps.
Never reverse order.

V. SPEC ENGINE FLOW (PSEUDOCODE)

Here is the clean build-ready version.

FOR each menu_item IN event.menu_sections:

    IF menu_item.quantity EXISTS:
        CONTINUE (sacred override)

    IF placement NOT defined:
        OUTPUT UNKNOWN
        CONTINUE

    guest_band = determine_guest_band(event.guest_count)

    redundancy_score = evaluate_redundancy(event.menu_sections)

    role = classify_item(menu_item)
        ‚Üí primary_protein
        ‚Üí filler
        ‚Üí dessert
        ‚Üí passed_app

    vessel = menu_item.vessel
        IF vessel empty:
            DO NOT GUESS
            OUTPUT UNKNOWN

    quantity = derive_quantity(
        guest_band,
        role,
        redundancy_score,
        placement
    )

    RETURN spec block:
        - vessel
        - quantity
        - flags (build_on_site, pack_separately)

VI. WHAT THE ENGINE MUST NEVER DO

‚ùå Linear scaling
‚ùå Equal distribution
‚ùå Normalize quantities
‚ùå Change vessels
‚ùå Merge items
‚ùå Optimize menu balance
‚ùå Write to print fields
‚ùå Overwrite Nick

VII. SPEC VS PACK-OUT SEPARATION

Spec Engine determines:

Food intent

Pan type

Volume suggestion

Pack-Out Engine determines:

Equipment

Static essentials

Bar/hydration additions

They are separate modules.

Final Definition

The FoodWerx Spec Engine is:

A pattern-based decision engine that mirrors historical catering behavior using guest bands and redundancy compression, while enforcing sacred human overrides and refusing to guess when confidence is insufficient.can you give me it in an omni promt for sonnet 
ok now i had 5.2 alayze my dropbox does this contradict anything.  this is for the speck engineYes.
Here is the Spec Engine Logic, clean, structured, and separated into:

Observed Dropbox Rules (non-negotiable)

Guardrails we added

Decision Order

Pseudocode version you can hand to Sonnet/Gemini

No fluff. No invention beyond what we explicitly layered.

üß† FOODWERX SPEC ENGINE LOGIC (CANONICAL)
I. CORE PRINCIPLES (LOCKED)
1Ô∏è‚É£ Human Placement Is Gospel

The engine reads:

Passed Appetizers

Presented Appetizers

Buffet ‚Äì Metal

Buffet ‚Äì China

Desserts

It may NEVER:

Move items between sections

Reinterpret placement

Infer placement

Change vessel type

If placement is unclear ‚Üí
UNKNOWN ‚Äî requires human decision

2Ô∏è‚É£ Quantity Logic Is Pattern-Based (NOT Linear)

The engine:

Does NOT use ounces-per-guest math

Does NOT divide guest count evenly across items

Does NOT auto-balance menu items

Instead it uses:

Guest count bands

Redundancy logic

Primary vs Filler distinction

Service interaction (passed + buffet compression)

3Ô∏è‚É£ Overrides Are Sacred

If a human has entered:

Quantity

Vessel

Notes

The engine MUST:

Leave it untouched

Never recalc

Never normalize

Engine may only initialize fields if they are empty.

4Ô∏è‚É£ Language Must Match Operational Terminology

Allowed vocabulary:

Full pan

Half pan

Round pan

Primary protein

Filler item

Light touch

Grazing volume

Server to build on site

Pack separately

No generic catering terms.
No industry yield charts.

II. OBSERVED BEHAVIOR RULES (FROM DROPBOX)
A. Guest Count Bands (Behavioral, Not Mathematical)

These are switches, not formulas.

Guest Count	Behavior
‚â§ 75	Conservative pan counts
75‚Äì125	Standard full-service behavior
125‚Äì175	Redundancy begins compressing items
175‚Äì250	Clear primary vs filler split
250+	Volume scaling flattens

Important:
Scaling is not proportional.

B. Redundancy Logic

If multiple proteins exist:

Each protein receives LESS than if solo.

If:

Pasta

Starch

Bread

Grazing displays

Passed appetizers

Are present:
‚Üí Buffet volume decreases.

If Passed + Buffet both exist:
‚Üí Buffet compression increases.

C. Placement-Specific Tendencies
Passed Apps

Smaller batches

Often marked:

‚ÄúServer to build on site‚Äù

‚ÄúPack separately‚Äù

Buffet Primary Protein

Drives chafer logic

Usually full or round pan

Buffet Filler

Often half pans

Sometimes no chafer

Desserts

Count logic differs (pieces vs pans)

Often less aggressive scaling

III. CHAFER / VESSEL LOGIC (LOCKED)

Per unique menu item:

Full pan ‚Üí 1 chafer

2 half pans ‚Üí 1 chafer

Odd half ‚Üí flag

Round pan ‚Üí round chafer

Enforced per item, not per quantity batch

Engine may never infer vessel type from:

‚ÄúHot‚Äù

‚ÄúCold‚Äù

Item name

IV. GUARDRAILS WE ADDED (ARCHITECTURAL TIGHTENING)

These are NOT Dropbox-derived but were intentionally layered.

1Ô∏è‚É£ Initialize-Only Pattern

Engine may:

Suggest default spec
ONLY IF field is empty.

After human edit:
‚Üí Spec becomes read-only.

2Ô∏è‚É£ Confidence Threshold

If:

Guest band conflicts with redundancy pattern

No historical pattern match

Placement is missing

Engine outputs:

UNKNOWN ‚Äî requires human decision

Never guess.

3Ô∏è‚É£ Decision Order Lock

The engine must evaluate in this order:

Menu item exists

Human placement selected

Guest count band determined

Redundancy evaluated

Primary vs filler evaluated

Vessel confirmed (or pre-set)

Quantity suggested (if empty)

Never skip steps.
Never reverse order.

V. SPEC ENGINE FLOW (PSEUDOCODE)

Here is the clean build-ready version.

FOR each menu_item IN event.menu_sections:

    IF menu_item.quantity EXISTS:
        CONTINUE (sacred override)

    IF placement NOT defined:
        OUTPUT UNKNOWN
        CONTINUE

    guest_band = determine_guest_band(event.guest_count)

    redundancy_score = evaluate_redundancy(event.menu_sections)

    role = classify_item(menu_item)
        ‚Üí primary_protein
        ‚Üí filler
        ‚Üí dessert
        ‚Üí passed_app

    vessel = menu_item.vessel
        IF vessel empty:
            DO NOT GUESS
            OUTPUT UNKNOWN

    quantity = derive_quantity(
        guest_band,
        role,
        redundancy_score,
        placement
    )

    RETURN spec block:
        - vessel
        - quantity
        - flags (build_on_site, pack_separately)

VI. WHAT THE ENGINE MUST NEVER DO

‚ùå Linear scaling
‚ùå Equal distribution
‚ùå Normalize quantities
‚ùå Change vessels
‚ùå Merge items
‚ùå Optimize menu balance
‚ùå Write to print fields
‚ùå Overwrite Nick

VII. SPEC VS PACK-OUT SEPARATION

Spec Engine determines:

Food intent

Pan type

Volume suggestion

Pack-Out Engine determines:

Equipment

Static essentials

Bar/hydration additions

They are separate modules.

Final Definition

The FoodWerx Spec Engine is:

A pattern-based decision engine that mirrors historical catering behavior using guest bands and redundancy compression, while enforcing sacred human overrides and refusing to guess when confidence is insufficient.can you give me it in an omni promt for sonnet 
ok now i had 5.2 alayze my dropbox does this contradict anything.  this is for the speck engineYes.
Here is the Spec Engine Logic, clean, structured, and separated into:

Observed Dropbox Rules (non-negotiable)

Guardrails we added

Decision Order

Pseudocode version you can hand to Sonnet/Gemini

No fluff. No invention beyond what we explicitly layered.

üß† FOODWERX SPEC ENGINE LOGIC (CANONICAL)
I. CORE PRINCIPLES (LOCKED)
1Ô∏è‚É£ Human Placement Is Gospel

The engine reads:

Passed Appetizers

Presented Appetizers

Buffet ‚Äì Metal

Buffet ‚Äì China

Desserts

It may NEVER:

Move items between sections

Reinterpret placement

Infer placement

Change vessel type

If placement is unclear ‚Üí
UNKNOWN ‚Äî requires human decision

2Ô∏è‚É£ Quantity Logic Is Pattern-Based (NOT Linear)

The engine:

Does NOT use ounces-per-guest math

Does NOT divide guest count evenly across items

Does NOT auto-balance menu items

Instead it uses:

Guest count bands

Redundancy logic

Primary vs Filler distinction

Service interaction (passed + buffet compression)

3Ô∏è‚É£ Overrides Are Sacred

If a human has entered:

Quantity

Vessel

Notes

The engine MUST:

Leave it untouched

Never recalc

Never normalize

Engine may only initialize fields if they are empty.

4Ô∏è‚É£ Language Must Match Operational Terminology

Allowed vocabulary:

Full pan

Half pan

Round pan

Primary protein

Filler item

Light touch

Grazing volume

Server to build on site

Pack separately

No generic catering terms.
No industry yield charts.

II. OBSERVED BEHAVIOR RULES (FROM DROPBOX)
A. Guest Count Bands (Behavioral, Not Mathematical)

These are switches, not formulas.

Guest Count	Behavior
‚â§ 75	Conservative pan counts
75‚Äì125	Standard full-service behavior
125‚Äì175	Redundancy begins compressing items
175‚Äì250	Clear primary vs filler split
250+	Volume scaling flattens

Important:
Scaling is not proportional.

B. Redundancy Logic

If multiple proteins exist:

Each protein receives LESS than if solo.

If:

Pasta

Starch

Bread

Grazing displays

Passed appetizers

Are present:
‚Üí Buffet volume decreases.

If Passed + Buffet both exist:
‚Üí Buffet compression increases.

C. Placement-Specific Tendencies
Passed Apps

Smaller batches

Often marked:

‚ÄúServer to build on site‚Äù

‚ÄúPack separately‚Äù

Buffet Primary Protein

Drives chafer logic

Usually full or round pan

Buffet Filler

Often half pans

Sometimes no chafer

Desserts

Count logic differs (pieces vs pans)

Often less aggressive scaling

III. CHAFER / VESSEL LOGIC (LOCKED)

Per unique menu item:

Full pan ‚Üí 1 chafer

2 half pans ‚Üí 1 chafer

Odd half ‚Üí flag

Round pan ‚Üí round chafer

Enforced per item, not per quantity batch

Engine may never infer vessel type from:

‚ÄúHot‚Äù

‚ÄúCold‚Äù

Item name

IV. GUARDRAILS WE ADDED (ARCHITECTURAL TIGHTENING)

These are NOT Dropbox-derived but were intentionally layered.

1Ô∏è‚É£ Initialize-Only Pattern

Engine may:

Suggest default spec
ONLY IF field is empty.

After human edit:
‚Üí Spec becomes read-only.

2Ô∏è‚É£ Confidence Threshold

If:

Guest band conflicts with redundancy pattern

No historical pattern match

Placement is missing

Engine outputs:

UNKNOWN ‚Äî requires human decision

Never guess.

3Ô∏è‚É£ Decision Order Lock

The engine must evaluate in this order:

Menu item exists

Human placement selected

Guest count band determined

Redundancy evaluated

Primary vs filler evaluated

Vessel confirmed (or pre-set)

Quantity suggested (if empty)

Never skip steps.
Never reverse order.

V. SPEC ENGINE FLOW (PSEUDOCODE)

Here is the clean build-ready version.

FOR each menu_item IN event.menu_sections:

    IF menu_item.quantity EXISTS:
        CONTINUE (sacred override)

    IF placement NOT defined:
        OUTPUT UNKNOWN
        CONTINUE

    guest_band = determine_guest_band(event.guest_count)

    redundancy_score = evaluate_redundancy(event.menu_sections)

    role = classify_item(menu_item)
        ‚Üí primary_protein
        ‚Üí filler
        ‚Üí dessert
        ‚Üí passed_app

    vessel = menu_item.vessel
        IF vessel empty:
            DO NOT GUESS
            OUTPUT UNKNOWN

    quantity = derive_quantity(
        guest_band,
        role,
        redundancy_score,
        placement
    )

    RETURN spec block:
        - vessel
        - quantity
        - flags (build_on_site, pack_separately)

VI. WHAT THE ENGINE MUST NEVER DO

‚ùå Linear scaling
‚ùå Equal distribution
‚ùå Normalize quantities
‚ùå Change vessels
‚ùå Merge items
‚ùå Optimize menu balance
‚ùå Write to print fields
‚ùå Overwrite Nick

VII. SPEC VS PACK-OUT SEPARATION

Spec Engine determines:

Food intent

Pan type

Volume suggestion

Pack-Out Engine determines:

Equipment

Static essentials

Bar/hydration additions

They are separate modules.

Final Definition

The FoodWerx Spec Engine is:

A pattern-based decision engine that mirrors historical catering behavior using guest bands and redundancy compression, while enforcing sacred human overrides and refusing to guess when confidence is insufficient.can you give me it in an omni promt for sonnet 
ok now i had 5.2 alayze my dropbox does this contradict anything.  this is for the speck engineYes.
Here is the Spec Engine Logic, clean, structured, and separated into:

Observed Dropbox Rules (non-negotiable)

Guardrails we added

Decision Order

Pseudocode version you can hand to Sonnet/Gemini

No fluff. No invention beyond what we explicitly layered.

üß† FOODWERX SPEC ENGINE LOGIC (CANONICAL)
I. CORE PRINCIPLES (LOCKED)
1Ô∏è‚É£ Human Placement Is Gospel

The engine reads:

Passed Appetizers

Presented Appetizers

Buffet ‚Äì Metal

Buffet ‚Äì China

Desserts

It may NEVER:

Move items between sections

Reinterpret placement

Infer placement

Change vessel type

If placement is unclear ‚Üí
UNKNOWN ‚Äî requires human decision

2Ô∏è‚É£ Quantity Logic Is Pattern-Based (NOT Linear)

The engine:

Does NOT use ounces-per-guest math

Does NOT divide guest count evenly across items

Does NOT auto-balance menu items

Instead it uses:

Guest count bands

Redundancy logic

Primary vs Filler distinction

Service interaction (passed + buffet compression)

3Ô∏è‚É£ Overrides Are Sacred

If a human has entered:

Quantity

Vessel

Notes

The engine MUST:

Leave it untouched

Never recalc

Never normalize

Engine may only initialize fields if they are empty.

4Ô∏è‚É£ Language Must Match Operational Terminology

Allowed vocabulary:

Full pan

Half pan

Round pan

Primary protein

Filler item

Light touch

Grazing volume

Server to build on site

Pack separately

No generic catering terms.
No industry yield charts.

II. OBSERVED BEHAVIOR RULES (FROM DROPBOX)
A. Guest Count Bands (Behavioral, Not Mathematical)

These are switches, not formulas.

Guest Count	Behavior
‚â§ 75	Conservative pan counts
75‚Äì125	Standard full-service behavior
125‚Äì175	Redundancy begins compressing items
175‚Äì250	Clear primary vs filler split
250+	Volume scaling flattens

Important:
Scaling is not proportional.

B. Redundancy Logic

If multiple proteins exist:

Each protein receives LESS than if solo.

If:

Pasta

Starch

Bread

Grazing displays

Passed appetizers

Are present:
‚Üí Buffet volume decreases.

If Passed + Buffet both exist:
‚Üí Buffet compression increases.

C. Placement-Specific Tendencies
Passed Apps

Smaller batches

Often marked:

‚ÄúServer to build on site‚Äù

‚ÄúPack separately‚Äù

Buffet Primary Protein

Drives chafer logic

Usually full or round pan

Buffet Filler

Often half pans

Sometimes no chafer

Desserts

Count logic differs (pieces vs pans)

Often less aggressive scaling

III. CHAFER / VESSEL LOGIC (LOCKED)

Per unique menu item:

Full pan ‚Üí 1 chafer

2 half pans ‚Üí 1 chafer

Odd half ‚Üí flag

Round pan ‚Üí round chafer

Enforced per item, not per quantity batch

Engine may never infer vessel type from:

‚ÄúHot‚Äù

‚ÄúCold‚Äù

Item name

IV. GUARDRAILS WE ADDED (ARCHITECTURAL TIGHTENING)

These are NOT Dropbox-derived but were intentionally layered.

1Ô∏è‚É£ Initialize-Only Pattern

Engine may:

Suggest default spec
ONLY IF field is empty.

After human edit:
‚Üí Spec becomes read-only.

2Ô∏è‚É£ Confidence Threshold

If:

Guest band conflicts with redundancy pattern

No historical pattern match

Placement is missing

Engine outputs:

UNKNOWN ‚Äî requires human decision

Never guess.

3Ô∏è‚É£ Decision Order Lock

The engine must evaluate in this order:

Menu item exists

Human placement selected

Guest count band determined

Redundancy evaluated

Primary vs filler evaluated

Vessel confirmed (or pre-set)

Quantity suggested (if empty)

Never skip steps.
Never reverse order.

V. SPEC ENGINE FLOW (PSEUDOCODE)

Here is the clean build-ready version.

FOR each menu_item IN event.menu_sections:

    IF menu_item.quantity EXISTS:
        CONTINUE (sacred override)

    IF placement NOT defined:
        OUTPUT UNKNOWN
        CONTINUE

    guest_band = determine_guest_band(event.guest_count)

    redundancy_score = evaluate_redundancy(event.menu_sections)

    role = classify_item(menu_item)
        ‚Üí primary_protein
        ‚Üí filler
        ‚Üí dessert
        ‚Üí passed_app

    vessel = menu_item.vessel
        IF vessel empty:
            DO NOT GUESS
            OUTPUT UNKNOWN

    quantity = derive_quantity(
        guest_band,
        role,
        redundancy_score,
        placement
    )

    RETURN spec block:
        - vessel
        - quantity
        - flags (build_on_site, pack_separately)

VI. WHAT THE ENGINE MUST NEVER DO

‚ùå Linear scaling
‚ùå Equal distribution
‚ùå Normalize quantities
‚ùå Change vessels
‚ùå Merge items
‚ùå Optimize menu balance
‚ùå Write to print fields
‚ùå Overwrite Nick

VII. SPEC VS PACK-OUT SEPARATION

Spec Engine determines:

Food intent

Pan type

Volume suggestion

Pack-Out Engine determines:

Equipment

Static essentials

Bar/hydration additions

They are separate modules.

Final Definition

The FoodWerx Spec Engine is:

A pattern-based decision engine that mirrors historical catering behavior using guest bands and redundancy compression, while enforcing sacred human overrides and refusing to guess when confidence is insufficient.can you give me it in an omni promt for sonnet 
ok now i had 5.2 alayze my dropbox does this contradict anything.  this is for the speck engineYes.
Here is the Spec Engine Logic, clean, structured, and separated into:

Observed Dropbox Rules (non-negotiable)

Guardrails we added

Decision Order

Pseudocode version you can hand to Sonnet/Gemini

No fluff. No invention beyond what we explicitly layered.

üß† FOODWERX SPEC ENGINE LOGIC (CANONICAL)
I. CORE PRINCIPLES (LOCKED)
1Ô∏è‚É£ Human Placement Is Gospel

The engine reads:

Passed Appetizers

Presented Appetizers

Buffet ‚Äì Metal

Buffet ‚Äì China

Desserts

It may NEVER:

Move items between sections

Reinterpret placement

Infer placement

Change vessel type

If placement is unclear ‚Üí
UNKNOWN ‚Äî requires human decision

2Ô∏è‚É£ Quantity Logic Is Pattern-Based (NOT Linear)

The engine:

Does NOT use ounces-per-guest math

Does NOT divide guest count evenly across items

Does NOT auto-balance menu items

Instead it uses:

Guest count bands

Redundancy logic

Primary vs Filler distinction

Service interaction (passed + buffet compression)

3Ô∏è‚É£ Overrides Are Sacred

If a human has entered:

Quantity

Vessel

Notes

The engine MUST:

Leave it untouched

Never recalc

Never normalize

Engine may only initialize fields if they are empty.

4Ô∏è‚É£ Language Must Match Operational Terminology

Allowed vocabulary:

Full pan

Half pan

Round pan

Primary protein

Filler item

Light touch

Grazing volume

Server to build on site

Pack separately

No generic catering terms.
No industry yield charts.

II. OBSERVED BEHAVIOR RULES (FROM DROPBOX)
A. Guest Count Bands (Behavioral, Not Mathematical)

These are switches, not formulas.

Guest Count	Behavior
‚â§ 75	Conservative pan counts
75‚Äì125	Standard full-service behavior
125‚Äì175	Redundancy begins compressing items
175‚Äì250	Clear primary vs filler split
250+	Volume scaling flattens

Important:
Scaling is not proportional.

B. Redundancy Logic

If multiple proteins exist:

Each protein receives LESS than if solo.

If:

Pasta

Starch

Bread

Grazing displays

Passed appetizers

Are present:
‚Üí Buffet volume decreases.

If Passed + Buffet both exist:
‚Üí Buffet compression increases.

C. Placement-Specific Tendencies
Passed Apps

Smaller batches

Often marked:

‚ÄúServer to build on site‚Äù

‚ÄúPack separately‚Äù

Buffet Primary Protein

Drives chafer logic

Usually full or round pan

Buffet Filler

Often half pans

Sometimes no chafer

Desserts

Count logic differs (pieces vs pans)

Often less aggressive scaling

III. CHAFER / VESSEL LOGIC (LOCKED)

Per unique menu item:

Full pan ‚Üí 1 chafer

2 half pans ‚Üí 1 chafer

Odd half ‚Üí flag

Round pan ‚Üí round chafer

Enforced per item, not per quantity batch

Engine may never infer vessel type from:

‚ÄúHot‚Äù

‚ÄúCold‚Äù

Item name

IV. GUARDRAILS WE ADDED (ARCHITECTURAL TIGHTENING)

These are NOT Dropbox-derived but were intentionally layered.

1Ô∏è‚É£ Initialize-Only Pattern

Engine may:

Suggest default spec
ONLY IF field is empty.

After human edit:
‚Üí Spec becomes read-only.

2Ô∏è‚É£ Confidence Threshold

If:

Guest band conflicts with redundancy pattern

No historical pattern match

Placement is missing

Engine outputs:

UNKNOWN ‚Äî requires human decision

Never guess.

3Ô∏è‚É£ Decision Order Lock

The engine must evaluate in this order:

Menu item exists

Human placement selected

Guest count band determined

Redundancy evaluated

Primary vs filler evaluated

Vessel confirmed (or pre-set)

Quantity suggested (if empty)

Never skip steps.
Never reverse order.

V. SPEC ENGINE FLOW (PSEUDOCODE)

Here is the clean build-ready version.

FOR each menu_item IN event.menu_sections:

    IF menu_item.quantity EXISTS:
        CONTINUE (sacred override)

    IF placement NOT defined:
        OUTPUT UNKNOWN
        CONTINUE

    guest_band = determine_guest_band(event.guest_count)

    redundancy_score = evaluate_redundancy(event.menu_sections)

    role = classify_item(menu_item)
        ‚Üí primary_protein
        ‚Üí filler
        ‚Üí dessert
        ‚Üí passed_app

    vessel = menu_item.vessel
        IF vessel empty:
            DO NOT GUESS
            OUTPUT UNKNOWN

    quantity = derive_quantity(
        guest_band,
        role,
        redundancy_score,
        placement
    )

    RETURN spec block:
        - vessel
        - quantity
        - flags (build_on_site, pack_separately)

VI. WHAT THE ENGINE MUST NEVER DO

‚ùå Linear scaling
‚ùå Equal distribution
‚ùå Normalize quantities
‚ùå Change vessels
‚ùå Merge items
‚ùå Optimize menu balance
‚ùå Write to print fields
‚ùå Overwrite Nick

VII. SPEC VS PACK-OUT SEPARATION

Spec Engine determines:

Food intent

Pan type

Volume suggestion

Pack-Out Engine determines:

Equipment

Static essentials

Bar/hydration additions

They are separate modules.

Final Definition

The FoodWerx Spec Engine is:

A pattern-based decision engine that mirrors historical catering behavior using guest bands and redundancy compression, while enforcing sacred human overrides and refusing to guess when confidence is insufficient.can you give me it in an omni promt for sonnet 
ok now i had 5.2 alayze my dropbox does this contradict anything.  this is for the speck engineYes.
Here is the Spec Engine Logic, clean, structured, and separated into:

Observed Dropbox Rules (non-negotiable)

Guardrails we added

Decision Order

Pseudocode version you can hand to Sonnet/Gemini

No fluff. No invention beyond what we explicitly layered.

üß† FOODWERX SPEC ENGINE LOGIC (CANONICAL)
I. CORE PRINCIPLES (LOCKED)
1Ô∏è‚É£ Human Placement Is Gospel

The engine reads:

Passed Appetizers

Presented Appetizers

Buffet ‚Äì Metal

Buffet ‚Äì China

Desserts

It may NEVER:

Move items between sections

Reinterpret placement

Infer placement

Change vessel type

If placement is unclear ‚Üí
UNKNOWN ‚Äî requires human decision

2Ô∏è‚É£ Quantity Logic Is Pattern-Based (NOT Linear)

The engine:

Does NOT use ounces-per-guest math

Does NOT divide guest count evenly across items

Does NOT auto-balance menu items

Instead it uses:

Guest count bands

Redundancy logic

Primary vs Filler distinction

Service interaction (passed + buffet compression)

3Ô∏è‚É£ Overrides Are Sacred

If a human has entered:

Quantity

Vessel

Notes

The engine MUST:

Leave it untouched

Never recalc

Never normalize

Engine may only initialize fields if they are empty.

4Ô∏è‚É£ Language Must Match Operational Terminology

Allowed vocabulary:

Full pan

Half pan

Round pan

Primary protein

Filler item

Light touch

Grazing volume

Server to build on site

Pack separately

No generic catering terms.
No industry yield charts.

II. OBSERVED BEHAVIOR RULES (FROM DROPBOX)
A. Guest Count Bands (Behavioral, Not Mathematical)

These are switches, not formulas.

Guest Count	Behavior
‚â§ 75	Conservative pan counts
75‚Äì125	Standard full-service behavior
125‚Äì175	Redundancy begins compressing items
175‚Äì250	Clear primary vs filler split
250+	Volume scaling flattens

Important:
Scaling is not proportional.

B. Redundancy Logic

If multiple proteins exist:

Each protein receives LESS than if solo.

If:

Pasta

Starch

Bread

Grazing displays

Passed appetizers

Are present:
‚Üí Buffet volume decreases.

If Passed + Buffet both exist:
‚Üí Buffet compression increases.

C. Placement-Specific Tendencies
Passed Apps

Smaller batches

Often marked:

‚ÄúServer to build on site‚Äù

‚ÄúPack separately‚Äù

Buffet Primary Protein

Drives chafer logic

Usually full or round pan

Buffet Filler

Often half pans

Sometimes no chafer

Desserts

Count logic differs (pieces vs pans)

Often less aggressive scaling

III. CHAFER / VESSEL LOGIC (LOCKED)

Per unique menu item:

Full pan ‚Üí 1 chafer

2 half pans ‚Üí 1 chafer

Odd half ‚Üí flag

Round pan ‚Üí round chafer

Enforced per item, not per quantity batch

Engine may never infer vessel type from:

‚ÄúHot‚Äù

‚ÄúCold‚Äù

Item name

IV. GUARDRAILS WE ADDED (ARCHITECTURAL TIGHTENING)

These are NOT Dropbox-derived but were intentionally layered.

1Ô∏è‚É£ Initialize-Only Pattern

Engine may:

Suggest default spec
ONLY IF field is empty.

After human edit:
‚Üí Spec becomes read-only.

2Ô∏è‚É£ Confidence Threshold

If:

Guest band conflicts with redundancy pattern

No historical pattern match

Placement is missing

Engine outputs:

UNKNOWN ‚Äî requires human decision

Never guess.

3Ô∏è‚É£ Decision Order Lock

The engine must evaluate in this order:

Menu item exists

Human placement selected

Guest count band determined

Redundancy evaluated

Primary vs filler evaluated

Vessel confirmed (or pre-set)

Quantity suggested (if empty)

Never skip steps.
Never reverse order.

V. SPEC ENGINE FLOW (PSEUDOCODE)

Here is the clean build-ready version.

FOR each menu_item IN event.menu_sections:

    IF menu_item.quantity EXISTS:
        CONTINUE (sacred override)

    IF placement NOT defined:
        OUTPUT UNKNOWN
        CONTINUE

    guest_band = determine_guest_band(event.guest_count)

    redundancy_score = evaluate_redundancy(event.menu_sections)

    role = classify_item(menu_item)
        ‚Üí primary_protein
        ‚Üí filler
        ‚Üí dessert
        ‚Üí passed_app

    vessel = menu_item.vessel
        IF vessel empty:
            DO NOT GUESS
            OUTPUT UNKNOWN

    quantity = derive_quantity(
        guest_band,
        role,
        redundancy_score,
        placement
    )

    RETURN spec block:
        - vessel
        - quantity
        - flags (build_on_site, pack_separately)

VI. WHAT THE ENGINE MUST NEVER DO

‚ùå Linear scaling
‚ùå Equal distribution
‚ùå Normalize quantities
‚ùå Change vessels
‚ùå Merge items
‚ùå Optimize menu balance
‚ùå Write to print fields
‚ùå Overwrite Nick

VII. SPEC VS PACK-OUT SEPARATION

Spec Engine determines:

Food intent

Pan type

Volume suggestion

Pack-Out Engine determines:

Equipment

Static essentials

Bar/hydration additions

They are separate modules.

Final Definition

The FoodWerx Spec Engine is:

A pattern-based decision engine that mirrors historical catering behavior using guest bands and redundancy compression, while enforcing sacred human overrides and refusing to guess when confidence is insufficient.can you give me it in an omni promt for sonnet 
ok now i had 5.2 alayze my dropbox does this contradict anything.  this is for the speck engineYes.
Here is the Spec Engine Logic, clean, structured, and separated into:

Observed Dropbox Rules (non-negotiable)

Guardrails we added

Decision Order

Pseudocode version you can hand to Sonnet/Gemini

No fluff. No invention beyond what we explicitly layered.

üß† FOODWERX SPEC ENGINE LOGIC (CANONICAL)
I. CORE PRINCIPLES (LOCKED)
1Ô∏è‚É£ Human Placement Is Gospel

The engine reads:

Passed Appetizers

Presented Appetizers

Buffet ‚Äì Metal

Buffet ‚Äì China

Desserts

It may NEVER:

Move items between sections

Reinterpret placement

Infer placement

Change vessel type

If placement is unclear ‚Üí
UNKNOWN ‚Äî requires human decision

2Ô∏è‚É£ Quantity Logic Is Pattern-Based (NOT Linear)

The engine:

Does NOT use ounces-per-guest math

Does NOT divide guest count evenly across items

Does NOT auto-balance menu items

Instead it uses:

Guest count bands

Redundancy logic

Primary vs Filler distinction

Service interaction (passed + buffet compression)

3Ô∏è‚É£ Overrides Are Sacred

If a human has entered:

Quantity

Vessel

Notes

The engine MUST:

Leave it untouched

Never recalc

Never normalize

Engine may only initialize fields if they are empty.

4Ô∏è‚É£ Language Must Match Operational Terminology

Allowed vocabulary:

Full pan

Half pan

Round pan

Primary protein

Filler item

Light touch

Grazing volume

Server to build on site

Pack separately

No generic catering terms.
No industry yield charts.

II. OBSERVED BEHAVIOR RULES (FROM DROPBOX)
A. Guest Count Bands (Behavioral, Not Mathematical)

These are switches, not formulas.

Guest Count	Behavior
‚â§ 75	Conservative pan counts
75‚Äì125	Standard full-service behavior
125‚Äì175	Redundancy begins compressing items
175‚Äì250	Clear primary vs filler split
250+	Volume scaling flattens

Important:
Scaling is not proportional.

B. Redundancy Logic

If multiple proteins exist:

Each protein receives LESS than if solo.

If:

Pasta

Starch

Bread

Grazing displays

Passed appetizers

Are present:
‚Üí Buffet volume decreases.

If Passed + Buffet both exist:
‚Üí Buffet compression increases.

C. Placement-Specific Tendencies
Passed Apps

Smaller batches

Often marked:

‚ÄúServer to build on site‚Äù

‚ÄúPack separately‚Äù

Buffet Primary Protein

Drives chafer logic

Usually full or round pan

Buffet Filler

Often half pans

Sometimes no chafer

Desserts

Count logic differs (pieces vs pans)

Often less aggressive scaling

III. CHAFER / VESSEL LOGIC (LOCKED)

Per unique menu item:

Full pan ‚Üí 1 chafer

2 half pans ‚Üí 1 chafer

Odd half ‚Üí flag

Round pan ‚Üí round chafer

Enforced per item, not per quantity batch

Engine may never infer vessel type from:

‚ÄúHot‚Äù

‚ÄúCold‚Äù

Item name

IV. GUARDRAILS WE ADDED (ARCHITECTURAL TIGHTENING)

These are NOT Dropbox-derived but were intentionally layered.

1Ô∏è‚É£ Initialize-Only Pattern

Engine may:

Suggest default spec
ONLY IF field is empty.

After human edit:
‚Üí Spec becomes read-only.

2Ô∏è‚É£ Confidence Threshold

If:

Guest band conflicts with redundancy pattern

No historical pattern match

Placement is missing

Engine outputs:

UNKNOWN ‚Äî requires human decision

Never guess.

3Ô∏è‚É£ Decision Order Lock

The engine must evaluate in this order:

Menu item exists

Human placement selected

Guest count band determined

Redundancy evaluated

Primary vs filler evaluated

Vessel confirmed (or pre-set)

Quantity suggested (if empty)

Never skip steps.
Never reverse order.

V. SPEC ENGINE FLOW (PSEUDOCODE)

Here is the clean build-ready version.

FOR each menu_item IN event.menu_sections:

    IF menu_item.quantity EXISTS:
        CONTINUE (sacred override)

    IF placement NOT defined:
        OUTPUT UNKNOWN
        CONTINUE

    guest_band = determine_guest_band(event.guest_count)

    redundancy_score = evaluate_redundancy(event.menu_sections)

    role = classify_item(menu_item)
        ‚Üí primary_protein
        ‚Üí filler
        ‚Üí dessert
        ‚Üí passed_app

    vessel = menu_item.vessel
        IF vessel empty:
            DO NOT GUESS
            OUTPUT UNKNOWN

    quantity = derive_quantity(
        guest_band,
        role,
        redundancy_score,
        placement
    )

    RETURN spec block:
        - vessel
        - quantity
        - flags (build_on_site, pack_separately)

VI. WHAT THE ENGINE MUST NEVER DO

‚ùå Linear scaling
‚ùå Equal distribution
‚ùå Normalize quantities
‚ùå Change vessels
‚ùå Merge items
‚ùå Optimize menu balance
‚ùå Write to print fields
‚ùå Overwrite Nick

VII. SPEC VS PACK-OUT SEPARATION

Spec Engine determines:

Food intent

Pan type

Volume suggestion

Pack-Out Engine determines:

Equipment

Static essentials

Bar/hydration additions

They are separate modules.

Final Definition

The FoodWerx Spec Engine is:

A pattern-based decision engine that mirrors historical catering behavior using guest bands and redundancy compression, while enforcing sacred human overrides and refusing to guess when confidence is insufficient.can you give me it in an omni promt for sonnet 
ok now i had 5.2 alayze my dropbox does this contradict anything.  this is for the speck engineYes.
Here is the Spec Engine Logic, clean, structured, and separated into:

Observed Dropbox Rules (non-negotiable)

Guardrails we added

Decision Order

Pseudocode version you can hand to Sonnet/Gemini

No fluff. No invention beyond what we explicitly layered.

üß† FOODWERX SPEC ENGINE LOGIC (CANONICAL)
I. CORE PRINCIPLES (LOCKED)
1Ô∏è‚É£ Human Placement Is Gospel

The engine reads:

Passed Appetizers

Presented Appetizers

Buffet ‚Äì Metal

Buffet ‚Äì China

Desserts

It may NEVER:

Move items between sections

Reinterpret placement

Infer placement

Change vessel type

If placement is unclear ‚Üí
UNKNOWN ‚Äî requires human decision

2Ô∏è‚É£ Quantity Logic Is Pattern-Based (NOT Linear)

The engine:

Does NOT use ounces-per-guest math

Does NOT divide guest count evenly across items

Does NOT auto-balance menu items

Instead it uses:

Guest count bands

Redundancy logic

Primary vs Filler distinction

Service interaction (passed + buffet compression)

3Ô∏è‚É£ Overrides Are Sacred

If a human has entered:

Quantity

Vessel

Notes

The engine MUST:

Leave it untouched

Never recalc

Never normalize

Engine may only initialize fields if they are empty.

4Ô∏è‚É£ Language Must Match Operational Terminology

Allowed vocabulary:

Full pan

Half pan

Round pan

Primary protein

Filler item

Light touch

Grazing volume

Server to build on site

Pack separately

No generic catering terms.
No industry yield charts.

II. OBSERVED BEHAVIOR RULES (FROM DROPBOX)
A. Guest Count Bands (Behavioral, Not Mathematical)

These are switches, not formulas.

Guest Count	Behavior
‚â§ 75	Conservative pan counts
75‚Äì125	Standard full-service behavior
125‚Äì175	Redundancy begins compressing items
175‚Äì250	Clear primary vs filler split
250+	Volume scaling flattens

Important:
Scaling is not proportional.

B. Redundancy Logic

If multiple proteins exist:

Each protein receives LESS than if solo.

If:

Pasta

Starch

Bread

Grazing displays

Passed appetizers

Are present:
‚Üí Buffet volume decreases.

If Passed + Buffet both exist:
‚Üí Buffet compression increases.

C. Placement-Specific Tendencies
Passed Apps

Smaller batches

Often marked:

‚ÄúServer to build on site‚Äù

‚ÄúPack separately‚Äù

Buffet Primary Protein

Drives chafer logic

Usually full or round pan

Buffet Filler

Often half pans

Sometimes no chafer

Desserts

Count logic differs (pieces vs pans)

Often less aggressive scaling

III. CHAFER / VESSEL LOGIC (LOCKED)

Per unique menu item:

Full pan ‚Üí 1 chafer

2 half pans ‚Üí 1 chafer

Odd half ‚Üí flag

Round pan ‚Üí round chafer

Enforced per item, not per quantity batch

Engine may never infer vessel type from:

‚ÄúHot‚Äù

‚ÄúCold‚Äù

Item name

IV. GUARDRAILS WE ADDED (ARCHITECTURAL TIGHTENING)

These are NOT Dropbox-derived but were intentionally layered.

1Ô∏è‚É£ Initialize-Only Pattern

Engine may:

Suggest default spec
ONLY IF field is empty.

After human edit:
‚Üí Spec becomes read-only.

2Ô∏è‚É£ Confidence Threshold

If:

Guest band conflicts with redundancy pattern

No historical pattern match

Placement is missing

Engine outputs:

UNKNOWN ‚Äî requires human decision

Never guess.

3Ô∏è‚É£ Decision Order Lock

The engine must evaluate in this order:

Menu item exists

Human placement selected

Guest count band determined

Redundancy evaluated

Primary vs filler evaluated

Vessel confirmed (or pre-set)

Quantity suggested (if empty)

Never skip steps.
Never reverse order.

V. SPEC ENGINE FLOW (PSEUDOCODE)

Here is the clean build-ready version.

FOR each menu_item IN event.menu_sections:

    IF menu_item.quantity EXISTS:
        CONTINUE (sacred override)

    IF placement NOT defined:
        OUTPUT UNKNOWN
        CONTINUE

    guest_band = determine_guest_band(event.guest_count)

    redundancy_score = evaluate_redundancy(event.menu_sections)

    role = classify_item(menu_item)
        ‚Üí primary_protein
        ‚Üí filler
        ‚Üí dessert
        ‚Üí passed_app

    vessel = menu_item.vessel
        IF vessel empty:
            DO NOT GUESS
            OUTPUT UNKNOWN

    quantity = derive_quantity(
        guest_band,
        role,
        redundancy_score,
        placement
    )

    RETURN spec block:
        - vessel
        - quantity
        - flags (build_on_site, pack_separately)

VI. WHAT THE ENGINE MUST NEVER DO

‚ùå Linear scaling
‚ùå Equal distribution
‚ùå Normalize quantities
‚ùå Change vessels
‚ùå Merge items
‚ùå Optimize menu balance
‚ùå Write to print fields
‚ùå Overwrite Nick

VII. SPEC VS PACK-OUT SEPARATION

Spec Engine determines:

Food intent

Pan type

Volume suggestion

Pack-Out Engine determines:

Equipment

Static essentials

Bar/hydration additions

They are separate modules.

Final Definition

The FoodWerx Spec Engine is:

A pattern-based decision engine that mirrors historical catering behavior using guest bands and redundancy compression, while enforcing sacred human overrides and refusing to guess when confidence is insufficient.